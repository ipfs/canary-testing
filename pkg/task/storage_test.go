package task

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/syndtr/goleveldb/leveldb"
	"github.com/syndtr/goleveldb/leveldb/storage"
)

func TestChangePrefix(t *testing.T) {
	id := "testing123"
	exp := "current:testing123"
	inmem := storage.NewMemStorage()
	db, err := leveldb.Open(inmem, nil)
	if err != nil {
		t.Fatal(err)
	}
	ts := &TaskStorage{db}

	// Add a task to one prefix, then change it to another.
	ts.Put(QUEUEPREFIX, &Task{
		ID: id,
	})
	ts.ChangePrefix(CURRENTPREFIX, QUEUEPREFIX, id)
	// In the database, I expect to see the task stored with the prefix
	exists, err := ts.db.Has([]byte(exp), nil)
	if err != nil {
		t.Fatal(err)
	}
	assert.True(t, exists)
}

// While in the CURRENT task state, make sure task state entry is recorded
func TestAppendTaskState(t *testing.T) {
	id := "testtesttest"
	inmem := storage.NewMemStorage()
	db, err := leveldb.Open(inmem, nil)
	if err != nil {
		t.Fatal(err)
	}
	ts := &TaskStorage{db}

	// Create a task in the current prefix so we can append states to its log.
	ts.Put(CURRENTPREFIX, &Task{
		ID: id,
	})

	// Through the lifetime of the task running, append state events to it.
	ts.AppendTaskState(id, StateProcessing)
	ts.AppendTaskState(id, StateComplete)

	// How many states are there?
	tsk, err := ts.Get(CURRENTPREFIX, id)
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, 2, len(tsk.States))
}

func TestArchive(t *testing.T) {
	inmem := storage.NewMemStorage()
	db, err := leveldb.Open(inmem, nil)
	if err != nil {
		t.Fatal(err)
	}
	ts := &TaskStorage{db}

	// Add tasks created in different times to the archive.
	// The ID will typically be generated by the system with the clock encoded.
	// For this test, generate meaningful IDs.
	for _, id := range []string{
		"9d352ba8-a9ea-11ea-84a9-ccb0daba35bf", // 2020-06-08 17:46:11.3170344 -0700 PDT
		"a35a0871-a9ea-11ea-a4cc-ccb0daba35bf", // 2020-06-08 17:46:21.6249457 -0700 PDT
		"a989e2f6-a9ea-11ea-8687-ccb0daba35bf", // 2020-06-08 17:46:32.0048886 -0700 PDT
		"afafccb3-a9ea-11ea-a140-ccb0daba35bf", // 2020-06-08 17:46:42.3196851 -0700 PDT
		"b5d8ea22-a9ea-11ea-b075-ccb0daba35bf", // 2020-06-08 17:46:52.6554658 -0700 PDT
		"bc0fc42a-a9ea-11ea-bbd8-ccb0daba35bf", // 2020-06-08 17:47:03.0812714 -0700 PDT
	} {
		tsk := Task{
			ID: id,
		}
		ts.Put(ARCHIVEPREFIX, &tsk)
	}
	// find all tasks between a certain date and time
	// I expect to find three of the tasks between this range.
	cali, err := time.LoadLocation("America/Los_Angeles")
	if err != nil {
		t.Fatal(err)
	}
	before := time.Date(2020, 6, 8, 17, 46, 20, 0, cali)
	after := time.Date(2020, 6, 8, 17, 46, 50, 0, cali)

	between, err := ts.ArchiveRange(before, after)
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, 3, len(between))
}
